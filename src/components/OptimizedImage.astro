---
import { Image } from 'astro:assets';

interface Props {
  src: string | ImageMetadata;
  alt: string;
  width?: number;
  height?: number;
  loading?: 'lazy' | 'eager';
  class?: string;
  fallback?: string;
  sizes?: string;
  quality?: number;
  format?: 'webp' | 'avif' | 'png' | 'jpg';
}

const {
  src,
  alt,
  width = 800,
  height,
  loading = 'lazy',
  class: className,
  fallback,
  sizes,
  quality = 80,
  format = 'webp'
} = Astro.props;

// Generate responsive srcset
const responsiveSizes = sizes || `
  (max-width: 768px) 100vw,
  (max-width: 1200px) 50vw,
  33vw
`;

// Calculate aspect ratio if height not provided
const aspectRatio = height ? width / height : 16 / 9;
const calculatedHeight = height || Math.round(width / aspectRatio);
---

<div class={`image-container ${className || ''}`}>
  <Image
    src={src}
    alt={alt}
    width={width}
    height={calculatedHeight}
    format={format}
    quality={quality}
    loading={loading}
    sizes={responsiveSizes}
    class="optimized-image"
  />
  {fallback && (
    <noscript>
      <img 
        src={fallback} 
        alt={alt}
        width={width}
        height={calculatedHeight}
        loading={loading}
      />
    </noscript>
  )}
</div>

<style>
  .image-container {
    position: relative;
    overflow: hidden;
    border-radius: 8px;
  }

  .optimized-image {
    width: 100%;
    height: auto;
    display: block;
    transition: transform 0.3s ease;
  }

  .image-container:hover .optimized-image {
    transform: scale(1.02);
  }

  /* Skeleton loading state */
  .image-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    z-index: -1;
  }

  @keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }

  /* Progressive enhancement for modern browsers */
  @supports (object-fit: cover) {
    .optimized-image {
      object-fit: cover;
    }
  }

  /* Intersection Observer loading states */
  .image-container[data-loaded="true"]::before {
    display: none;
  }

  /* Accessibility improvements */
  @media (prefers-reduced-motion: reduce) {
    .optimized-image {
      transition: none;
    }
    
    .image-container:hover .optimized-image {
      transform: none;
    }

    .image-container::before {
      animation: none;
    }
  }

  /* Dark mode support */
  @media (prefers-color-scheme: dark) {
    .image-container::before {
      background: linear-gradient(90deg, #2a2a2a 25%, #3a3a3a 50%, #2a2a2a 75%);
    }
  }
</style>

<script>
  // Enhanced lazy loading with Intersection Observer
  const imageContainers = document.querySelectorAll('.image-container');
  
  if ('IntersectionObserver' in window) {
    const imageObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const container = entry.target;
          const img = container.querySelector('.optimized-image');
          
          if (img) {
            img.addEventListener('load', () => {
              container.setAttribute('data-loaded', 'true');
            });
            
            img.addEventListener('error', () => {
              // Fallback to placeholder or error state
              container.classList.add('image-error');
            });
          }
          
          observer.unobserve(container);
        }
      });
    }, {
      rootMargin: '50px 0px',
      threshold: 0.1
    });

    imageContainers.forEach(container => {
      imageObserver.observe(container);
    });
  } else {
    // Fallback for browsers without Intersection Observer
    imageContainers.forEach(container => {
      container.setAttribute('data-loaded', 'true');
    });
  }
</script>